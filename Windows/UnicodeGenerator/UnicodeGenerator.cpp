#include <fstream>
#include <iostream>
#include <unordered_set>

#include <String/String.h>
#include <String/Key.h>
#include <Exception/Exception.h>
#include <Misc/FilePath.h>

using namespace PGE;

#define PGE_UNICODE_ASSERT_FILE(stream) PGE_ASSERT(stream.good(), "Stream is not good!")

static String paramsToMapType(const String& key, const String& value) {
    return "std::unordered_map<" + key + ", " + value + ">";
}

static constexpr int READ_BUFFER_SIZE = 256;
static constexpr const char* INDENT = "    ";
static constexpr const char* TAIL = "};";
static const String MAP_TYPE = paramsToMapType("wchar", "wchar");
static const String MULTI_FOLD_MAP_TYPE = paramsToMapType("wchar", "std::vector<wchar>");

struct Mapping {
    String from;
    String to;
};

struct MultiMapping {
    String from;
    std::vector<String> to;
};

static String rawToChar(const String& str) {
    return "u'\\u" + str + "'";
}

static String entriesToPair(const String& a, const String& b) {
    return "{ " + rawToChar(a) + ", " + rawToChar(b) + " },";
}

static String toMapHead(const String& mapType, const String& identifier) {
    return "const " + mapType + " Unicode::" + identifier + " = " + mapType + " {";
}

static std::ostream& operator<<(std::ostream& stream, const std::vector<Mapping>& mappings) {
    for (const Mapping& mapping : mappings) {
        stream << INDENT << entriesToPair(mapping.from, mapping.to) << std::endl;
    }
    return stream;
}

static std::ostream& operator<<(std::ostream& stream, const std::vector<MultiMapping>& mappings) {
    for (const MultiMapping& mapping : mappings) {
        stream << INDENT << "{ " + rawToChar(mapping.from) << ", { ";
        for (const String& str : mapping.to) {
            stream << rawToChar(str) << ", ";
        }
        stream << "} }," << std::endl;
    }
    return stream;
}

int main() {
    std::ofstream out;
    out.open("../../Src/String/Unicode.cpp");
    PGE_UNICODE_ASSERT_FILE(out);

    out << "// AUTOGENERATED FILE" << std::endl;
    out << "// DO NOT EDIT" << std::endl;
    out << std::endl;
    out << "#include \"Unicode.h\"" << std::endl;
    out << std::endl;
    out << "using namespace PGE;" << std::endl;
    out << std::endl;

    std::vector<Mapping> fullFolding;

    char buffer[READ_BUFFER_SIZE];
    std::ifstream in;
    in.open("CaseFolding.txt");
    PGE_UNICODE_ASSERT_FILE(in);

    out << toMapHead(MAP_TYPE, "FOLDING") << std::endl;
    while (!in.eof()) {
        in.getline(buffer, READ_BUFFER_SIZE);
        String line = buffer;
        if (line.byteLength() == 0 || *line.charAt(0) == L'#') { continue; }
        std::vector<String> params = line.split(";", false);
        params[0] = params[0].trim();
        // We reached UTF-32 range!
        if (params[0].byteLength() == 5) { break; }
        wchar type = *params[1].trim().charAt(0);
        if (type == 'C') {
            out << INDENT << entriesToPair(params[0], params[2].trim()) << std::endl;
        } else if (type == 'F') {
            out << INDENT << entriesToPair(params[0], "FFFF") << std::endl;
            fullFolding.push_back({ params[0], params[2].trim() });
        }
    }
    in.close();
    out << TAIL << std::endl;

    out << std::endl;
    out << toMapHead(MULTI_FOLD_MAP_TYPE, "MULTI_FOLDING") << std::endl;
    for (Mapping& mapping : fullFolding) {
        out << INDENT << "{ " << rawToChar(mapping.from) << ", { ";
        std::vector<String> splitChars = mapping.to.split(" ", true);
        for (String& ch : splitChars) {
            out << rawToChar(ch) << ", ";
        }
        out << "} }," << std::endl;
    }
    out << TAIL << std::endl;

    out << std::endl;

    std::vector<Mapping> up;
    std::vector<Mapping> down;
    std::vector<MultiMapping> multiUp;
    std::vector<MultiMapping> multiDown;
    std::unordered_set<String::Key> setUp;
    std::unordered_set<String::Key> setDown;

    // MANUAL OVERRIDE
    up.push_back({ "00DF", "1E9E" });
    setUp.insert("00DF");
    //

    in.open("SpecialCasing.txt");
    PGE_UNICODE_ASSERT_FILE(in);
    while (!in.eof()) {
        in.getline(buffer, READ_BUFFER_SIZE);
        String line = buffer;
        if (line.byteLength() == 0 || *line.charAt(0) == L'#') { continue; }
        std::vector<String> params = line.split(";", false);
        // We don't want any conditional mappings.
        if (*params[4].trim().charAt(0) != L'#') { continue; }
        if (params[3].byteLength() != 0) {
            std::vector<String> split = params[3].split(" ", true);
            // It must actually multi-fold.
            if (split.size() != 1 && setUp.find(params[0]) == setUp.end()) {
                multiUp.push_back({ params[0], split });
                up.push_back({ params[0], "FFFF" });
                setUp.insert(params[0]);
            }
        }
        if (params[1].byteLength() != 0) {
            std::vector<String> split = params[1].split(" ", true);
            // It must actually multi-fold.
            if (split.size() != 1 && setDown.find(params[0]) == setDown.end()) {
                multiDown.push_back({ params[0], split });
                down.push_back({ params[0], "FFFF" });
                setDown.insert(params[0]);
            }
        }
    }
    in.close();

    in.open("UnicodeData.txt");
    PGE_UNICODE_ASSERT_FILE(in);
    while (!in.eof()) {
        in.getline(buffer, READ_BUFFER_SIZE);
        String line = buffer;
        if (line.byteLength() == 0 || *line.charAt(0) == L'#') { continue; }
        std::vector<String> params = line.split(";", false);
        // We reached UTF-32 range!
        if (params[0].byteLength() == 5) { break; }
        if (params[12].byteLength() != 0 && setUp.find(params[0]) == setUp.end()) {
            up.push_back({ params[0], params[12] });
        }
        if (params[13].byteLength() != 0 && setDown.find(params[0]) == setDown.end()) {
            down.push_back({ params[0], params[13] });
        }
    }
    in.close();

    out << toMapHead(MAP_TYPE, "UP") << std::endl;
    out << up;
    out << TAIL << std::endl;

    out << std::endl;

    out << toMapHead(MAP_TYPE, "DOWN") << std::endl;
    out << down;
    out << TAIL << std::endl;

    out << std::endl;

    out << toMapHead(MULTI_FOLD_MAP_TYPE, "MULTI_UP") << std::endl;
    out << multiUp;
    out << TAIL << std::endl;

    out << std::endl;

    out << toMapHead(MULTI_FOLD_MAP_TYPE, "MULTI_DOWN") << std::endl;
    out << multiDown;
    out << TAIL << std::endl;

    out.close();

    std::cout << "Generated Unicode code!" << std::endl;
    return 0;
}
